{"version":3,"file":"List-b3266ee0.js","sources":["../../src/PRIVATE_List/ListRoles.ts","../../src/PRIVATE_List/ListItem.tsx","../../src/PRIVATE_List/Sparkle.tsx","../../src/PRIVATE_List/List.tsx","../../src/PRIVATE_List/useHandleRemoveCurrentKey.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { Roles } from '../UNSAFE_ListView';\nimport { HTMLAttributesSignalExcluded } from '../utils/UNSAFE_attributeUtils';\n\n/**\n * List Roles need to be kept in matching sets, this module encapsulates the sets\n *\n * @param ariaRole\n * @returns matching, valid set of roles\n */\n\nconst getListViewRoles = (\n  ariaRole: Roles\n): {\n  list: HTMLAttributesSignalExcluded['role'];\n  item: HTMLAttributesSignalExcluded['role'];\n  cell: HTMLAttributesSignalExcluded['role'];\n} => {\n  switch (ariaRole) {\n    case 'listbox':\n      return { list: 'listbox', item: 'presentation', cell: 'option' };\n    case 'treegrid':\n      return { list: 'treegrid', item: 'row', cell: 'gridcell' };\n    default:\n      return { list: 'grid', item: 'row', cell: 'gridcell' };\n  }\n};\n\nexport { getListViewRoles };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren } from 'preact';\nimport { memo } from 'preact/compat';\nimport { useRef, useMemo } from 'preact/hooks';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { TabbableModeContext } from '../hooks/UNSAFE_useTabbableMode';\nimport { SelectionMode, CurrentItemVariant, ListItemContext } from '../UNSAFE_Collection';\nimport { FocusTrap } from '../UNSAFE_FocusTrap';\nimport { useId } from '../hooks/UNSAFE_useId';\nimport { Roles } from '../UNSAFE_ListView';\nimport { getListViewRoles } from './ListRoles';\nimport { useInteractionStyle } from '../hooks/UNSAFE_useInteractionStyle';\nimport { mergeInterpolations } from '../utils/UNSAFE_mergeInterpolations';\nimport { flexitemInterpolations } from '../utils/UNSAFE_interpolations/flexitem';\nimport type { FlexitemProps } from '../utils/UNSAFE_interpolations/flexitem';\nimport { listItemStyles, listItemMultiVariantStyles } from './themes/ListStyles.css';\n\n// default style class for items in ListView\nexport const ITEM_STYLE_CLASS = 'oj-c-listview-item';\nexport const ITEM_SELECTOR = '.' + ITEM_STYLE_CLASS;\n\n/**\n * Props for the ListViewItem Component\n */\nexport type Props<K, D> = {\n  children: (context: ListItemContext<K, D>) => ComponentChildren;\n  context: ListItemContext<K, D>;\n  itemData: D;\n  itemDepth?: number;\n  isFocused: boolean;\n  isFocusRingVisible: boolean;\n  isActive: boolean;\n  isGridlineVisible: boolean;\n  isSelected: boolean;\n  isTopGridlineVisible?: boolean;\n  isTabbable?: boolean;\n  role: Roles;\n  selectionMode: SelectionMode;\n  suggestion?: 'end' | true;\n  currentItemVariant?: CurrentItemVariant;\n};\n\n/**\n * The internal component used to render a single item in ListView.\n */\nexport function ListViewItem<K extends string | number, D>({\n  children,\n  context,\n  itemDepth,\n  isFocused,\n  isFocusRingVisible,\n  isActive,\n  isGridlineVisible,\n  isSelected,\n  isTopGridlineVisible = false,\n  isTabbable = false,\n  role,\n  selectionMode,\n  suggestion,\n  currentItemVariant\n}: Props<K, D>) {\n  const rootRef = useRef<HTMLDivElement>(null);\n  const roles = useMemo(() => getListViewRoles(role), [role]);\n  const itemKey = context.metadata.key;\n  const itemIndex = context.index;\n\n  // some roles come with related aria attributes which need to be set\n  const cellRoleAttributes =\n    roles.cell === 'option'\n      ? {\n          role: roles.cell,\n          'aria-posinset': itemIndex + 1,\n          'aria-setsize': -1\n        }\n      : {\n          role: roles.cell\n        };\n\n  // don't bubble Arrow Up and Down events to parent when in isTabbable mode\n  // this bubbling causes the outer CollectionFocus ring to change index while in the isTabbable mode.\n  const handleKeyDown = (event: KeyboardEvent) => {\n    if (isTabbable && (event.key === 'ArrowDown' || event.key === 'ArrowUp')) {\n      event.stopPropagation();\n    }\n  };\n\n  const { interactionProps, applyActiveStyle, applyHoverStyle, applyPseudoHoverStyle } =\n    useInteractionStyle();\n\n  const variantClasses = listItemMultiVariantStyles({\n    selectable: isSelectable(selectionMode, isSelected) ? 'isSelectable' : 'notSelectable',\n    selected: isSelected ? 'isSelected' : 'notSelected',\n    selectedSingle:\n      isSelected && selectionMode === 'single' ? 'isSelectedSingle' : 'notSelectedSingle',\n    needsEventsHover: applyHoverStyle ? 'isNeedsEventsHover' : 'notNeedsEventsHover',\n    pseudoHover: applyPseudoHoverStyle ? 'isPseudoHover' : 'notPseudoHover',\n    active: applyActiveStyle || isActive ? 'isActive' : 'notActive',\n    focusHighlight:\n      currentItemVariant === 'highlight' && isFocused ? 'isFocusHighlight' : 'notFocusHighlight',\n    focusRingVisible:\n      isFocusRingVisible && isFocused ? 'isFocusRingVisible' : 'notFocusRingVisible',\n    gridlineTop: isTopGridlineVisible ? 'visible' : 'hidden',\n    gridlineBottom:\n      isGridlineVisible ||\n      (suggestion === 'end' && !isGridlineVisible && (!isSelected || selectionMode !== 'single'))\n        ? 'visible'\n        : 'hidden'\n  });\n  const classes = classNames([ITEM_STYLE_CLASS, variantClasses]);\n  const styleInterpolations = mergeInterpolations<FlexitemProps>([\n    ...Object.values(flexitemInterpolations)\n  ]);\n  const { class: cls, ...cellStyles } = styleInterpolations({\n    flex: '1 1 auto',\n    alignSelf: 'center'\n  });\n  const cellClasses = classNames([\n    cls,\n    selectionMode === 'multiple' && listItemStyles.checkboxContainer\n  ]);\n\n  // todo: use translated text for selector\n  // note cannot put focus on gridcell div since JAWS will not read the aria-rowindex\n  // correctly, so unfortunately needed another div\n  return (\n    <div\n      aria-rowindex={itemIndex + 1}\n      aria-level={itemDepth}\n      data-oj-key={itemKey}\n      class={classes}\n      ref={rootRef}\n      role={roles.item}\n      {...(suggestion && { 'data-oj-suggestion': true })}\n      {...(typeof itemKey === 'number' && { 'data-oj-key-type': 'number' })}\n      {...interactionProps}>\n      <div\n        id={useId()}\n        style={cellStyles}\n        class={cellClasses}\n        aria-posinset={itemIndex + 1}\n        aria-setsize={-1}\n        onKeyDown={handleKeyDown}\n        aria-colindex={1}\n        aria-selected={selectionMode !== 'none' ? isSelected : undefined}\n        {...cellRoleAttributes}>\n        <TabbableModeContext.Provider value={{ isTabbable }}>\n          <FocusTrap isDisabled={!isTabbable} restoreFocusRef={false}>\n            {children(context)}\n          </FocusTrap>\n        </TabbableModeContext.Provider>\n      </div>\n    </div>\n  );\n}\n\n/**\n * Helper method to determine whether item is selectable\n * @returns true if item is selectable (show hover effect), false otherwise\n */\nconst isSelectable = (selectionMode: SelectionMode, isItemSelected: boolean) => {\n  return selectionMode !== 'none' && (selectionMode === 'multiple' || !isItemSelected);\n};\n\nexport const MemoizeListViewItem = memo(ListViewItem, (prev: any, next: any) => {\n  if (prev && next) {\n    return (\n      prev.children === next.children &&\n      prev.isFocused === next.isFocused &&\n      prev.isFocusRingVisible === next.isFocusRingVisible &&\n      prev.isSelected === next.isSelected &&\n      prev.isTabbable === next.isTabbable &&\n      prev.isActive === next.isActive &&\n      prev.suggestion === next.suggestion &&\n      compareListItemContext(prev.context, next.context)\n    );\n  }\n  return false;\n});\n\nconst compareListItemContext = <K, D>(ctx1: ListItemContext<K, D>, ctx2: ListItemContext<K, D>) => {\n  return (\n    ctx1.data === ctx2.data &&\n    ctx1.index === ctx2.index &&\n    ctx1.isSelected === ctx2.isSelected &&\n    ctx1.metadata.key === ctx2.metadata.key\n  );\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { Metadata } from '../UNSAFE_Collection';\n\nconst SPARKLE_STYLE_CLASS = 'oj-collection-sparkle';\n\nimport { sparkleStyles } from './themes/ListStyles.css';\n\n/**\n * A sparkle component for smart suggestion indicator in ListView\n * @param sparkleHeight the height of sparkle\n */\nexport function Sparkle({ sparkleHeight }: { sparkleHeight: number }) {\n  if (sparkleHeight <= 0) {\n    return null;\n  }\n\n  const height = sparkleHeight + 'px';\n  const sparkleClasses = classNames([sparkleStyles.base]);\n  const containerClasses = classNames([sparkleStyles.container, SPARKLE_STYLE_CLASS]);\n\n  return (\n    <div key=\"sparkle\" class={containerClasses}>\n      <div class={sparkleClasses} style={{ height }}></div>\n    </div>\n  );\n}\n\n/**\n * A helper function that finds the data with suggestions, and\n * returns the corresponding keys\n * @param dataState\n */\nexport const findSuggestions = <K, D>(\n  data: { data: D; metadata: Metadata<K> }[],\n  count: number\n) => {\n  if (count === 0) {\n    return null;\n  }\n\n  const suggestionsData = data.slice(0, count);\n  return suggestionsData.reduce((suggestions, value, index) => {\n    const key = value.metadata.key;\n\n    if (index === count - 1) {\n      suggestions.set(key, 'end');\n    } else {\n      suggestions.set(key, true);\n    }\n\n    return suggestions;\n  }, new Map<K, 'end' | true>());\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { RefObject } from 'preact';\nimport { useRef, useCallback, useEffect, useState, useMemo } from 'preact/hooks';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { mergeProps } from '../utils/UNSAFE_mergeProps';\nimport { containsKey, Keys, isKeyDefined } from '../utils/UNSAFE_keys';\nimport {\n  DataState,\n  ItemContext,\n  ListItemContext,\n  Metadata,\n  Range,\n  SelectionDetail\n} from '../UNSAFE_Collection';\nimport { LoadMoreCollection, LOADMORE_STYLE_CLASS } from '../PRIVATE_LoadMoreCollection';\nimport { VirtualizedCollection, PLACEHOLDER_STYLE_CLASS } from '../PRIVATE_VirtualizedCollection';\nimport { ViewportConfig } from '../hooks/UNSAFE_useViewportIntersect';\nimport { ListViewItem, ITEM_SELECTOR, MemoizeListViewItem } from './ListItem';\nimport { SelectionRangeDetail, useSelection } from '../hooks/PRIVATE_useSelection';\nimport { useCurrentKey } from '../hooks/PRIVATE_useCurrentKey';\nimport { useCollectionFocusRing } from '../hooks/PRIVATE_useCollectionFocusRing';\nimport { useTabbableModeSet } from '../hooks/PRIVATE_useTabbableModeSet';\nimport { useItemAction } from '../hooks/PRIVATE_useItemAction';\nimport { SkeletonContainer } from './SkeletonContainer';\nimport { Skeleton } from '../UNSAFE_Skeleton';\nimport { Flex } from '../UNSAFE_Flex';\nimport {\n  getFirstVisibleKey,\n  getPrevNextKey,\n  findElementByKey,\n  keyExtractor\n} from '../utils/PRIVATE_collectionUtils';\nimport { Selector } from '../UNSAFE_Selector';\nimport { Props } from '../UNSAFE_ListView';\nimport { getListViewRoles } from './ListRoles';\nimport { useHandleRemoveCurrentKey } from './useHandleRemoveCurrentKey';\nimport { findSuggestions, Sparkle } from './Sparkle';\nimport { useCollectionGestureContext } from '../hooks/PRIVATE_useCollectionGestureContext';\nimport { listStyles } from './themes/ListStyles.css';\n\n/**\n * Component that renders items as a flat list.\n * In order to maximize performance, only items that are visible in the viewport are rendered.\n */\nexport function List<K extends string | number, D>({\n  'aria-label': ariaLabel,\n  'aria-labelledby': ariaLabelledBy,\n  allowTabbableMode = true,\n  children,\n  currentKey,\n  data,\n  gridlines,\n  loadingIndicator = defaultLoadingIndicator,\n  onCurrentKeyChange,\n  onLoadRange,\n  onSelectionChange,\n  onItemAction,\n  rangeExtractor,\n  role = 'grid',\n  selectedKeys = emptyKeys as Keys<K>,\n  selectionMode = 'none',\n  viewportConfig,\n  currentItemVariant = 'none',\n  promotedSection,\n  isVirtualized = true,\n  customItemRenderer,\n  eventHandlers,\n  scrollToVisibleOffset\n}: Props<K, D>) {\n  const rootRef = useRef<HTMLDivElement>(null);\n  const listRoles = useMemo(() => getListViewRoles(role), [role]);\n\n  // tracking the anchor key which is used for shift+click selection\n  const anchorKey = useRef<K | undefined>();\n\n  // tracking pending selection/current key that is not in current data\n  const pendingSelection = useRef<{ detail: SelectionRangeDetail<K>; range: Range }>();\n  const pendingCurrentKey = useRef<K>();\n\n  const [active, setActive] = useState<boolean>(false);\n\n  // tracking sparkle height\n  const [sparkleHeight, setSparkleHeight] = useState<number>(0);\n\n  const showGridline = (index: number) => {\n    // show bottom gridlines for each item, and for the last item if specified\n    return (\n      gridlines?.item === 'visible' &&\n      (index + 1 !== data?.totalSize || gridlines?.bottom === 'visible')\n    );\n  };\n\n  const showGridlineTop = () => {\n    // show the top gridline for the first item\n    return gridlines?.item === 'visible' && gridlines?.top === 'visible';\n  };\n\n  const ariaMultiSelectable = selectionMode === 'none' ? undefined : selectionMode === 'multiple';\n  const ariaRowCount =\n    data === null ? undefined : data.sizePrecision === 'exact' ? data.totalSize : -1;\n\n  const classes = classNames([listStyles.base]);\n\n  // find out whether the current key was there before in prev render\n  // and adjust current key as needed.  This should be run before other\n  // useEffect(s) that could also alter current key.\n  useHandleRemoveCurrentKey(data, currentKey, onCurrentKeyChange);\n\n  const { currentKeyProps } = useCurrentKey(\n    (element) => keyExtractor(element, ITEM_SELECTOR),\n    selectionMode !== 'multiple',\n    getPrevNextKey(rootRef.current, currentKey, true, ITEM_SELECTOR),\n    getPrevNextKey(rootRef.current, currentKey, false, ITEM_SELECTOR),\n    undefined,\n    undefined,\n    currentKey,\n    onCurrentKeyChange\n  );\n\n  const listViewContains = (elem: Element | null) => {\n    return !!rootRef.current?.contains(elem);\n  };\n\n  const [showFocusRing, focusRingProps] = useCollectionFocusRing(listViewContains, [\n    'ArrowUp',\n    'ArrowDown'\n  ]);\n\n  let pendingFocusRingChange = false;\n  const [isCurrentTabbableKey, tabbableModeProps] = useTabbableModeSet(\n    listViewContains,\n    (element) => {\n      // we don't want List to go into Tabbable mode when user clicks on expander\n      return isExpander(element) ? null : (keyExtractor(element, ITEM_SELECTOR) as K);\n    },\n    currentKey,\n    // handle clean-up on disabling of the mode\n    (target: EventTarget | null, isKeyboardEvent) => {\n      if (listViewContains(target as Element)) {\n        // delay focus reset for keyboard disable so focus is reset to ListView after the FocusTrap blur lifecycle completes.\n        // pointer initiated changes will fire the onBlur organically and delaying the focus, just generates an unwanted second blur\n        if (isKeyboardEvent) {\n          // do not show a focus ring during this timeOut\n          pendingFocusRingChange = true;\n          setTimeout(() => {\n            rootRef.current?.focus();\n          }, 0);\n        } else {\n          rootRef.current?.focus();\n        }\n      }\n      // otherwise target is not in list (including body, which target should be null in that case)\n    },\n    // set currentKey when mode is enabled\n    (key: K) => {\n      onCurrentKeyChange && onCurrentKeyChange({ value: key });\n    }\n  );\n\n  useEffect(() => {\n    if (currentKey != null && rootRef.current) {\n      const elem = findElementByKey(rootRef.current, currentKey, ITEM_SELECTOR);\n      if (elem) {\n        const activeDescendant = rootRef.current.getAttribute('aria-activedescendant');\n        const cell = elem.querySelector(`[role=${listRoles.cell}]`);\n        if (cell && activeDescendant !== cell.id) {\n          // update aria-activedescendant for screenreader\n          rootRef.current.setAttribute('aria-activedescendant', cell.id);\n\n          const scroller = viewportConfig?.scroller();\n          const offset = scrollToVisibleOffset ? scrollToVisibleOffset(rootRef.current) : 0;\n          // make sure item is visible\n          scrollToVisible(elem, scroller != null ? scroller : rootRef.current, offset);\n        }\n      }\n    }\n    // listen to data because the current item would re-render when the virtualizer\n    // is fetching data or updating the data, i.e. the id of current item would be updated,\n    // so the currentKey itself couldn't guarantee the root has latest aria-activedescendant\n  }, [currentKey, data, listRoles.cell, viewportConfig]);\n\n  const handleSelectionChange = useCallback(\n    (detail: SelectionDetail<K>) => {\n      if (onSelectionChange) {\n        if (detail.value.all === false && detail.value.keys.size > 0) {\n          // the last key selected by a user gesture is the anchor key\n          anchorKey.current = Array.from(detail.value.keys.values()).pop();\n        }\n        onSelectionChange(detail);\n      }\n    },\n    [anchorKey, onSelectionChange]\n  );\n\n  const handleSelectionRangeChange = useCallback(\n    (detail: SelectionRangeDetail<K>) => {\n      if (data && onSelectionChange) {\n        const value = handleSelectionRange(detail, data);\n        if (Array.isArray(value)) {\n          onSelectionChange({ value: { all: false, keys: new Set(value) }, target: null });\n        } else {\n          pendingSelection.current = {\n            detail: detail,\n            range: { offset: data.offset, count: data.data.length }\n          };\n          onLoadRange(value);\n        }\n      }\n    },\n    [data, onSelectionChange, onLoadRange]\n  );\n\n  const handleInitialFocus = useCallback(() => {\n    if (\n      rootRef.current &&\n      onCurrentKeyChange &&\n      (!allowTabbableMode || isCurrentTabbableKey(undefined))\n    ) {\n      const firstKey =\n        pendingCurrentKey.current || (getFirstVisibleKey(rootRef.current, ITEM_SELECTOR) as K);\n      if (isKeyDefined(firstKey)) {\n        onCurrentKeyChange({ value: firstKey });\n      }\n    }\n  }, [allowTabbableMode, onCurrentKeyChange, isCurrentTabbableKey]);\n\n  /**\n   * Used by allowTabbableMode = false, to prevent focus from getting onto checkboxes on click\n   * @param event\n   */\n  const handleSelectorFocusCapture = useCallback(\n    (event: FocusEvent) => {\n      const key = keyExtractor(event.target as HTMLElement, ITEM_SELECTOR);\n      if (key && (event.relatedTarget as HTMLElement)?.getAttribute('type') === 'checkbox') {\n        rootRef.current?.focus();\n        if (onCurrentKeyChange && key) {\n          onCurrentKeyChange({ value: key as K });\n        }\n      }\n    },\n    [onCurrentKeyChange]\n  );\n\n  const handleFocus = useCallback(\n    (event: FocusEvent) => {\n      if (isExpander(event.target as HTMLElement)) {\n        rootRef.current?.focus();\n        const key = keyExtractor(event.target as HTMLElement, ITEM_SELECTOR);\n        if (onCurrentKeyChange && key) {\n          onCurrentKeyChange({ value: key as K });\n        }\n        return;\n      }\n      !isKeyDefined(currentKey) && onCurrentKeyChange && handleInitialFocus();\n      !allowTabbableMode && handleSelectorFocusCapture(event);\n    },\n    [\n      allowTabbableMode,\n      currentKey,\n      handleInitialFocus,\n      handleSelectorFocusCapture,\n      onCurrentKeyChange\n    ]\n  );\n\n  const value = useCollectionGestureContext();\n\n  const { selectionProps } = useSelection(\n    (element: HTMLElement) => {\n      if (element === rootRef.current) {\n        return currentKey === undefined ? null : currentKey;\n      }\n      return keyExtractor(element, ITEM_SELECTOR) as K;\n    },\n    selectedKeys,\n    selectionMode,\n    false,\n    'replace',\n    value === 'embedded',\n    handleSelectionChange,\n    anchorKey.current,\n    currentKey,\n    (currentKey: K | undefined, isPrev: boolean) =>\n      getPrevNextKey(rootRef.current, currentKey, isPrev, ITEM_SELECTOR),\n    undefined,\n    (key: K) => {\n      if (rootRef.current) {\n        const elem = findElementByKey(rootRef.current, key, ITEM_SELECTOR);\n        if (elem) {\n          const scroller = viewportConfig?.scroller();\n          const offset = scrollToVisibleOffset ? scrollToVisibleOffset(rootRef.current) : 0;\n          scrollToVisible(elem, scroller != null ? scroller : rootRef.current, offset);\n        }\n      }\n    },\n    handleSelectionRangeChange\n  );\n\n  if (data && pendingSelection.current !== undefined && onSelectionChange) {\n    const keys = handleSelectionRange(pendingSelection.current.detail, data);\n    if (Array.isArray(keys)) {\n      onSelectionChange({ value: { all: false, keys: new Set(keys) }, target: null });\n    }\n    const range = pendingSelection.current\n      ? pendingSelection.current.range\n      : { offset: data.offset, count: data.data.length };\n    data = adjustDataState(data, range);\n    pendingSelection.current = undefined;\n    onLoadRange(range);\n  }\n\n  const suggestions = useMemo(\n    () => data && promotedSection && findSuggestions(data.data, promotedSection.count),\n    [data, promotedSection]\n  );\n\n  // TODO: check suggestions before Sparkle would cause a scrolling issue\n  const sparkleIndicator = <Sparkle sparkleHeight={sparkleHeight}></Sparkle>;\n\n  const itemActionProps = useItemAction(\n    currentKey,\n    data,\n    onItemAction,\n    ITEM_SELECTOR,\n    value === 'embedded'\n  );\n\n  useEffect(() => {\n    // update sparkleHeight only when we have suggestions\n    // avoid unnecessary iterating through elements\n    if (suggestions) {\n      const placeholder = rootRef.current?.querySelector(\n        '.' + PLACEHOLDER_STYLE_CLASS\n      ) as HTMLElement;\n      let height = placeholder?.offsetHeight || 0;\n      const suggestionItems = rootRef.current?.querySelectorAll('[data-oj-suggestion]');\n      suggestionItems?.forEach((item) => (height += (item as HTMLElement).offsetHeight));\n      setSparkleHeight(height);\n    }\n  }, [suggestions]);\n\n  // returns an ListItemContext based on ItemContext (added metadata and selector)\n  const getItemContext = useCallback(\n    (context: ItemContext<{ data: D; metadata: Metadata<K> }>) => {\n      const selectorRenderer =\n        selectionMode === 'multiple'\n          ? () => (\n              <Selector\n                onChange={handleSelectionChange}\n                rowKey={context.data.metadata.key}\n                selectedKeys={selectedKeys}></Selector>\n            )\n          : undefined;\n\n      return {\n        index: context.index,\n        data: context.data.data,\n        metadata: context.data.metadata,\n        selector: selectorRenderer\n      };\n    },\n    [selectionMode, selectedKeys, handleSelectionChange]\n  );\n\n  const ItemComponent = isVirtualized ? ListViewItem : MemoizeListViewItem;\n\n  const childrenComponent = (context: ItemContext<{ data: D; metadata: Metadata<K> }>) => {\n    const listItemContext = getItemContext(context);\n    const suggestion = suggestions?.get(listItemContext.metadata.key);\n    const isTabbable = allowTabbableMode && isCurrentTabbableKey(listItemContext.metadata.key);\n    const isFocused = currentKey === listItemContext.metadata.key && !isTabbable;\n    const isActive = isFocused && active;\n    const isSelected = containsKey(selectedKeys, listItemContext.metadata.key);\n    const isFocusRingVisible = isFocused && showFocusRing && !pendingFocusRingChange;\n    const listItemFunc = (ctx: ListItemContext<K, D>, otherProps?: any) => (\n      <ItemComponent\n        key={listItemContext.metadata.key}\n        context={ctx}\n        isFocused={isFocused}\n        isFocusRingVisible={isFocusRingVisible}\n        isActive={isActive}\n        isGridlineVisible={showGridline(listItemContext.index)}\n        isSelected={isSelected}\n        isTabbable={allowTabbableMode && isCurrentTabbableKey(listItemContext.metadata.key)}\n        role={role}\n        selectionMode={selectionMode}\n        currentItemVariant={currentItemVariant}\n        {...(suggestion && { suggestion })}\n        {...(listItemContext.index === 0 && { isTopGridlineVisible: showGridlineTop() })}\n        {...otherProps}>\n        {children}\n      </ItemComponent>\n    );\n\n    // if customItemRenderer is specified (ExpandableList and GroupedList)\n    // create a custom context with additional info including a function\n    // that helps create the default item component\n    if (customItemRenderer) {\n      const customRendererContext = {\n        listItemContext,\n        isFocused,\n        isFocusRingVisible,\n        isSelected,\n        isTabbable,\n        isActive,\n        defaultListItem: listItemFunc\n      };\n      return customItemRenderer(customRendererContext);\n    }\n    return listItemFunc(listItemContext);\n  };\n\n  viewportConfig = getViewportConfig(rootRef, viewportConfig);\n\n  /**\n   * Need to track pointer down element to set currentItem when initial focus happens\n   */\n  const handlePointerDown = useCallback((event: PointerEvent) => {\n    const key = keyExtractor(event.target as HTMLElement, ITEM_SELECTOR);\n    if (isKeyDefined(key)) {\n      pendingCurrentKey.current = key as K;\n    }\n  }, []);\n\n  const handleKeyDown = useCallback(\n    (event: KeyboardEvent) => {\n      if (event.key === ' ' && currentKey && selectionMode !== 'none') {\n        setActive(true);\n      }\n    },\n    [currentKey, selectionMode, setActive]\n  );\n\n  const handleKeyUp = useCallback(() => {\n    setActive(false);\n  }, [setActive]);\n\n  // if data is not specified, listview should show loading indicator\n  // todo: replace placeholder with actual SkeletonContainer component (Ash is working on)\n  return (\n    <div\n      {...mergeProps(\n        allowTabbableMode ? tabbableModeProps : {},\n        currentKeyProps,\n        focusRingProps,\n        selectionProps,\n        itemActionProps,\n        {\n          onFocus: handleFocus,\n          onPointerDown: handlePointerDown,\n          onKeyDown: handleKeyDown,\n          onKeyUp: handleKeyUp\n        },\n        eventHandlers !== undefined ? eventHandlers : {}\n      )}\n      role={role}\n      aria-rowcount={ariaRowCount}\n      aria-colcount={1}\n      ref={rootRef}\n      class={classes}\n      tabIndex={0}\n      aria-label={ariaLabel}\n      aria-labelledby={ariaLabelledBy}\n      aria-multiselectable={ariaMultiSelectable}>\n      {data == null ? (\n        loadingIndicator\n      ) : isVirtualized ? (\n        <VirtualizedCollection\n          data={data}\n          itemSelector={ITEM_SELECTOR}\n          loadMoreIndicator={defaultLoadMoreIndicator}\n          onLoadRange={onLoadRange}\n          rangeExtractor={rangeExtractor}\n          suggestions={sparkleIndicator}\n          viewportConfig={viewportConfig}>\n          {childrenComponent}\n        </VirtualizedCollection>\n      ) : (\n        <LoadMoreCollection\n          data={data.data}\n          loadMoreIndicator={defaultLoadMoreIndicator}\n          hasMore={data.sizePrecision === 'atLeast' && data.data.length <= data.totalSize}\n          onLoadMore={() => {\n            data && onLoadRange({ offset: 0, count: data.data.length + 25 });\n          }}\n          suggestions={sparkleIndicator}\n          viewportConfig={viewportConfig}>\n          {childrenComponent}\n        </LoadMoreCollection>\n      )}\n    </div>\n  );\n}\n\nconst isExpander = (elem: HTMLElement) => {\n  if (elem.parentElement && elem.parentElement.classList.contains('oj-listview-expander')) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * A helper function to make sure specified elem is visible in the specified container\n */\nconst scrollToVisible = (elem: Element, scroller: Element, offset: number) => {\n  if (elem && scroller) {\n    if ((elem as any).scrollIntoViewIfNeeded) {\n      // for Safari, we'll need the non-standard scrollIntoViewIfNeeded\n      (elem as any).scrollIntoViewIfNeeded();\n    } else {\n      elem.scrollIntoView({ block: 'nearest' });\n    }\n    if (offset > 0) {\n      const scrollerBounds = scroller.getBoundingClientRect();\n      const elemBounds = elem.getBoundingClientRect();\n      const diff = scrollerBounds.top + offset - elemBounds.top;\n      if (diff > 0) {\n        scroller.scrollTop = scroller.scrollTop - diff;\n      }\n    }\n  }\n};\n\nconst getViewportConfig = (rootRef: RefObject<HTMLElement>, config?: ViewportConfig) => {\n  return (\n    config ?? {\n      scroller: () => {\n        return rootRef.current;\n      }\n    }\n  );\n};\n\nconst emptyKeys = { all: false, keys: new Set() };\n\nconst handleSelectionRange = <K, D>(\n  detail: SelectionRangeDetail<K>,\n  dataState: DataState<K, D>\n) => {\n  const keys = dataState.data.map((value: { data: D; metadata: Metadata<K> }) => {\n    return value.metadata.key;\n  });\n  const startIndex = keys.indexOf(detail.value.start);\n  const endIndex = keys.indexOf(detail.value.end);\n  const minIndex = Math.min(startIndex, endIndex);\n  const maxIndex = Math.max(startIndex, endIndex);\n  if (minIndex === -1) {\n    // return a range to fetch so we can find all the keys, maxIndex should not be -1\n    return { offset: 0, count: dataState.totalSize };\n  } else {\n    // range of keys are in the current viewport, return them\n    return keys.slice(minIndex, maxIndex + 1);\n  }\n};\n\nconst defaultLoadingIndicator = (\n  <SkeletonContainer minimumCount={25}>\n    {() => {\n      return (\n        <Flex height=\"12x\" align=\"center\">\n          <Skeleton height=\"4x\" />\n        </Flex>\n      );\n    }}\n  </SkeletonContainer>\n);\n\nconst defaultLoadMoreIndicator = (\n  <div class={LOADMORE_STYLE_CLASS}>\n    <SkeletonContainer minimumCount={3}>\n      {() => {\n        return (\n          <Flex height=\"12x\" align=\"center\">\n            <Skeleton height=\"4x\" />\n          </Flex>\n        );\n      }}\n    </SkeletonContainer>\n  </div>\n);\n\n/**\n * Adjust the DataState as needed if it contains more than needed for the specified range\n */\nconst adjustDataState = <K, D>(dataState: DataState<K, D>, range: Range | null) => {\n  if (range) {\n    // prevent range offset from being larger than the data state\n    const safeRangeOffset = Math.min(range.offset, dataState.offset + dataState.totalSize);\n    const diff = safeRangeOffset - dataState.offset;\n    if (diff > 0) {\n      dataState = {\n        offset: safeRangeOffset,\n        data: dataState.data.slice(diff, diff + range.count),\n        totalSize: dataState.totalSize,\n        sizePrecision: dataState.sizePrecision\n      };\n    }\n  }\n  return dataState;\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useEffect, useRef } from 'preact/hooks';\nimport { DataState, CurrentKeyDetail } from 'src/UNSAFE_Collection';\n\n/**\n * Hook to detect and handle when the current key has been removed\n * and try to find the next available current key.\n * TODO: put in its own private module as we should be able to share\n * between other Collection components.\n * @param dataState\n * @param currentKey\n * @param onChange\n */\nexport function useHandleRemoveCurrentKey<K, D>(\n  dataState: DataState<K, D> | null,\n  currentKey?: K,\n  onChange?: (detail: CurrentKeyDetail<K>) => void\n) {\n  const prevDataState = useRef<DataState<K, D> | null>();\n\n  useEffect(() => {\n    const oldDataState = prevDataState.current;\n    if (\n      currentKey &&\n      onChange &&\n      oldDataState &&\n      dataState &&\n      oldDataState.offset === dataState.offset &&\n      oldDataState !== dataState\n    ) {\n      const newKeys = dataState.data.map((dataMetadata) => {\n        return dataMetadata.metadata.key;\n      });\n      // first check if currentKey exists in new data, if it is then we\n      // don't need to do anything\n      if (newKeys.indexOf(currentKey) === -1) {\n        const oldKeys = oldDataState?.data.map((dataMetadata) => {\n          return dataMetadata.metadata.key;\n        });\n        // figure out what the new currentKey should be\n        let index = oldKeys.indexOf(currentKey);\n        if (index > -1) {\n          const backward = index === oldKeys.length - 1;\n          while (index >= 0 && index < oldKeys.length) {\n            index = backward ? index - 1 : index + 1;\n            const newCurrentKey = oldKeys[index];\n            if (newKeys.indexOf(newCurrentKey) > -1) {\n              onChange({ value: newCurrentKey });\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    // update previous DataState\n    prevDataState.current = dataState;\n  }, [dataState, currentKey, onChange]);\n}\n"],"names":["getListViewRoles","ariaRole","list","item","cell","ITEM_STYLE_CLASS","ITEM_SELECTOR","ListViewItem","children","context","itemDepth","isFocused","isFocusRingVisible","isActive","isGridlineVisible","isSelected","isTopGridlineVisible","isTabbable","role","selectionMode","suggestion","currentItemVariant","rootRef","useRef","roles","useMemo","itemKey","metadata","key","itemIndex","index","cellRoleAttributes","interactionProps","applyActiveStyle","applyHoverStyle","applyPseudoHoverStyle","useInteractionStyle","variantClasses","listItemMultiVariantStyles","selectable","isSelectable","selected","selectedSingle","needsEventsHover","pseudoHover","active","focusHighlight","focusRingVisible","gridlineTop","gridlineBottom","classes","classNames","styleInterpolations","mergeInterpolations","Object","values","flexitemInterpolations","class","cls","cellStyles","flex","alignSelf","cellClasses","listItemStyles","checkboxContainer","_jsx","jsx","ref","id","useId","style","onKeyDown","event","stopPropagation","undefined","TabbableModeContext","Provider","value","FocusTrap","isDisabled","restoreFocusRef","isItemSelected","MemoizeListViewItem","memo","prev","next","compareListItemContext","ctx1","ctx2","data","SPARKLE_STYLE_CLASS","Sparkle","sparkleHeight","height","sparkleClasses","sparkleStyles","base","containerClasses","container","isExpander","elem","parentElement","classList","contains","scrollToVisible","scroller","offset","scrollIntoViewIfNeeded","scrollIntoView","block","scrollerBounds","getBoundingClientRect","elemBounds","diff","top","scrollTop","getViewportConfig","config","current","emptyKeys","all","keys","Set","handleSelectionRange","detail","dataState","map","startIndex","indexOf","start","endIndex","end","minIndex","Math","min","maxIndex","max","count","totalSize","slice","defaultLoadingIndicator","SkeletonContainer","minimumCount","Flex","align","Skeleton","defaultLoadMoreIndicator","LOADMORE_STYLE_CLASS","adjustDataState","range","safeRangeOffset","sizePrecision","ariaLabel","ariaLabelledBy","allowTabbableMode","currentKey","gridlines","loadingIndicator","onCurrentKeyChange","onLoadRange","onSelectionChange","onItemAction","rangeExtractor","selectedKeys","viewportConfig","promotedSection","isVirtualized","customItemRenderer","eventHandlers","scrollToVisibleOffset","listRoles","anchorKey","pendingSelection","pendingCurrentKey","setActive","useState","setSparkleHeight","ariaMultiSelectable","ariaRowCount","listStyles","onChange","prevDataState","useEffect","oldDataState","newKeys","dataMetadata","oldKeys","backward","length","newCurrentKey","useHandleRemoveCurrentKey","currentKeyProps","useCurrentKey","element","keyExtractor","getPrevNextKey","listViewContains","showFocusRing","focusRingProps","useCollectionFocusRing","pendingFocusRingChange","isCurrentTabbableKey","tabbableModeProps","useTabbableModeSet","target","isKeyboardEvent","setTimeout","focus","findElementByKey","activeDescendant","getAttribute","querySelector","setAttribute","handleSelectionChange","useCallback","size","Array","from","pop","handleSelectionRangeChange","isArray","handleInitialFocus","firstKey","getFirstVisibleKey","isKeyDefined","handleSelectorFocusCapture","relatedTarget","handleFocus","useCollectionGestureContext","selectionProps","useSelection","isPrev","suggestions","reduce","set","Map","findSuggestions","sparkleIndicator","itemActionProps","useItemAction","placeholder","PLACEHOLDER_STYLE_CLASS","offsetHeight","suggestionItems","querySelectorAll","forEach","getItemContext","selectorRenderer","Selector","rowKey","selector","ItemComponent","childrenComponent","listItemContext","get","containsKey","listItemFunc","ctx","otherProps","bottom","defaultListItem","handlePointerDown","handleKeyDown","handleKeyUp","mergeProps","onFocus","onPointerDown","onKeyUp","tabIndex","VirtualizedCollection","itemSelector","loadMoreIndicator","LoadMoreCollection","hasMore","onLoadMore"],"mappings":"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"}